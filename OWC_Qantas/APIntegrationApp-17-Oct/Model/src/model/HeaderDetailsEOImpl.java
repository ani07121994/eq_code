package model;

import java.util.Date;

import oracle.jbo.Key;
import oracle.jbo.RowInconsistentException;
import oracle.jbo.domain.Number;
import oracle.jbo.server.AttributeDefImpl;
import oracle.jbo.server.EntityDefImpl;
import oracle.jbo.server.EntityImpl;
import oracle.jbo.server.TransactionEvent;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Tue Jul 19 18:23:13 IST 2016
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class HeaderDetailsEOImpl extends EntityImpl {
    private static EntityDefImpl mDefinitionObject;

    /**
     * This is the default constructor (do not remove).
     */
    public HeaderDetailsEOImpl() {
    }

    /**
     * @param invoiceId key constituent

     * @return a Key object based on given key constituents.
     */
    public static Key createPrimaryKey(Number invoiceId) {
        return new Key(new Object[]{invoiceId});
    }

    /**
     * @return the definition object for this instance class.
     */
    public static synchronized EntityDefImpl getDefinitionObject() {
        if (mDefinitionObject == null) {
            mDefinitionObject = EntityDefImpl.findDefObject("model.HeaderDetailsEO");
        }
        return mDefinitionObject;
    }


    /**
     * Add locking logic here.
     */
        public void lock() {
            try {
                super.lock();
            }catch(RowInconsistentException e) {
                    checkInconsistentAttrs();
                    throw(e);
            }
        }

            private void checkInconsistentAttrs() {
               System.out.println("----- HeaderDetailsEOImpl : checkInconsistentAttrs : "+new Date()); 
            int count = getAttributeCount();
                Object[] currValues = new Object[count];
                boolean[] attributeChanges = new boolean[count];
                for (int i=0; i<count; i++) {
                    currValues[i] = getAttribute(i);
                    attributeChanges[i] = isAttributeChanged(i);
                }
                refresh(REFRESH_WITH_DB_FORGET_CHANGES);
                // For each attribute...
                for (int i=0; i<count; i++) {
                    Object origValue = getPostedAttribute(i);
                    Object currDbValue = getAttribute(i);
                    if ((origValue == null && currDbValue != null) ||
                        (origValue != null &&
                         (currDbValue == null ||
                          ! origValue.equals(currDbValue))))
                {
                    System.out.println("Inconsistent attribute " + getAttributeNames()[i]);
                    System.out.println("  Queried from DB = " + origValue);
                    System.out.println("  Now in DB = " + currDbValue);
                }
                     if (attributeChanges[i]) {
                         populateAttributeAsChanged(i, currValues[i]);
                     } else {
                         populateAttribute(i, currValues[i]);
                     }
                }
        }

    /**
     * Custom DML update/insert/delete logic here.
     * @param operation the operation type
     * @param e the transaction event
     */
    protected void doDML(int operation, TransactionEvent e) {
        super.doDML(operation, e);
    }
}
